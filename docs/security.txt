Overview
========

The application uses a number of techniques to prevent malevolent activity.

These include:

    - Login Authentication
    - Request origin checking
    - CSRF Countermeasures
    - XSS Countermeasures
    - SQL Injection Countermeasures


Login Authentication
--------------------

The user needs to log into the system with a username/password pair. The
username is their email address and is stored as is in the database. Passwords
are stored in the database using the Unix crypt(3) mechanism using the SHA-512
hashing method.

Upon successful login, a session cookie is created in the users browser, this
is what the application uses to track which user is which.


Request origin checking
-----------------------

On the login page, there is a checkbox labelled, 'Restrict this session to your
IP address', this is ticked by default. What this does is check that subsequent
requests from the user come from the same IP address that they logged in from.

While far from fool proof, think NAT, it's a simple thing to do with little
risk of downside.

This would help to prevent things like session hi-jacking.


CSRF Countermeasures
--------------------

CSRF (Cross Site Request Forgery) is an attack where by the attacker gets the
victim to submit a form/data to the victims website without their knowledge or
consent. The classic example is an attacker tricks a user into submitting a
form on the victims bank website transfering their money to the attacker.

For this to work the user would have to already be logged into their banks
website while also clicking the attackers link which may be masquerading as
some great deal. The victim, rather than seeing said great deal is now cleaned
out.

There are various ways to combat this with varying degrees of effectiveness.

The route taken in this application is to place a csrf token on all forms.

When a form is sent to the user, a csrf token is generated by
generate_csrf_token() (8 bytes from /dev/urandom and sha1'd) and placed in a
hidden input field on the form with add_csrf_token().

e.g

<input type = "hidden" name = "csrf_token"
 value = "0721d0db8a3dc0d9ce6ebd5ce85b3761a2f21351c836fd4ba076680b8122a6a3" />

This token is also stored in the users session (server side).

It's perhaps important to clarify, that on each page that uses csrf tokens,
the token is _regenerated_ each time the page is loaded.

When a form is subsequently submitted by the user, a check is made to see if
the csrf token on the form matches the one that was stored in the users
session with valid_csrf_token()

If the tokens don't match, we don't perform the requested action and just bail
out.

This should be pretty effective as it's improbable that an attacker will guess
the right csrf token to use.

These functions are defined in src/csrf.c


XSS Countermeasures
-------------------

XSS (Cross Site Scripting). In its simplest form, this involves an attacker
having the browser parse some of their own html when rendering to a user.

An attacker may have used some text input box on a form that they know will
then be viewed by others, to input some of their own html and or javascript
etc. Then when a user comes along and views that, their browser will also read
and parse the html inputted by the attacker which could be programmed to do
any number of things, such as send the users browser cookie information back
to them.

The approach taken here is to be lenient in what we accept but strict in what
we send.

Thus we don't scan and munge data inputted into forms to remove html tags and
other stuff which may be nefarious. What we do instead is filter output going
to the browser.

The way this is handled is that we send user controlled output through a filter
function, de_xss(). That is any data which comes from an untrusted source that
is subsequently displayed in a browser gets run through that function.

What it does is replace any instances of; &, <, >, ", ' and / with their
textual/hex entity equivalents.

Suppose someone had set their name to John Doe<script>...</script>, this would
be outputted to the browser as; John Doe&lt;script&gt;...&lt;&#x2F;script&gt;
The output they would see on the screen would be as they entered it, but the
browser won't interpret that as html.

de_xss() is defined in src/utils.c


SQL Injection Countermeasures
-----------------------------

SQL injection attacks are when an attacker tries to put some SQL into an input
field on a form for example and have that executed by the database. e.g

In a 'mail me my password input box', an attacker might input

    x';UPDATE members SET email = 'attacker@example.com' WHERE
	email = 'bob@example.com

Thus attempting to change the email address of bob@example.com to their own.
They can then use the 'mail me my password link' again using their
attacker@example.com email address and see if they get sent a password.

Seeing as we are using MySQL, we use the mysql_real_escape_string() function to
make safe any SQL queries using user input. Now, the above example is sent to
MySQL as;

    'x\';UPDATE members SET email = \'attacker@exmaple.com\' WHERE email
	= \'bob@example.com'

Notice the 's have been escaped and the string has been rendered harmless.
